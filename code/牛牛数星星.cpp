/**
 *
 * 一闪一闪亮晶晶，满天都是小星星，牛牛晚上闲来无聊，便躺在床上数星星。
牛牛把星星图看成一个平面，左上角为原点(坐标为(1, 1))。现在有n颗星星，他给每颗星星都标上坐标(xi，yi)，表示这颗星星在第x行，第y列。
现在，牛牛想问你m个问题，给你两个点的坐标(a1, b1)(a2，b2)，表示一个矩形的左上角的点坐标和右下角的点坐标，请问在这个矩形内有多少颗星星（边界上的点也算是矩形内）。 

输入描述:
第一行输入一个数字n(1≤n≤100000)，表示星星的颗数。
接下来的n行，每行输入两个数xi和yi(1≤xi，yi≤1000），表示星星的位置。
然后输入一个数字m(1≤m≤100000), 表示牛牛询问问题的个数。
接下来m行，每行输入四个数字a1，b1，a2，b2(1≤a1＜a2≤1000), (1≤b1＜b2≤1000）
题目保证两颗星星不会存在于同一个位置。

输出描述:
输出一共包含m行，每行表示与之对应的每个问题的答案。



从数据规模可以看到，我们一共有10万颗星星以及最多10万次查询，
如果我们每次查询都把给出的范围内遍历一遍的话肯定会超时。那么，我们就需要换一种方法。因为我们只需要得到一个矩形范围内的星星的数量，
们就可以先跑一遍整个数据范围，找到这个点的左上方向一共有多少颗星星，并把它标记出来。
那么，我们要得到的矩形范围内的星星数量就变为了这个矩形右下角的点的值减去这个矩形左下角左边那个点的值再减去这个矩形右上角上面那个点
值再加上这个矩形左上角的左上边那个点的值（可以想象一下容斥定理）。
那么，我们只需要遍历一次1000*1000的地图就行了，每个查询可以O（1）来获取。
 */

#include <bits/stdc++.h>
using namespace std;

const int maxn = 1005;

int n,m;
int num[maxn][maxn];
int mp[maxn][maxn];
int x,y;
int a1,b1,a2,b2;
 
int main(){
	memset(num,0,sizeof(num));
	memset(mp,0,sizeof(mp));
    cin>>n;
    for (int i = 0; i < n; ++i)
    {
    	cin>>x>>y;
    	mp[x][y]++;
    }

    for (int i = 0; i < maxn; ++i)
    {
    	for (int j = 0; j < maxn; ++j)
    	{
    		num[i][j] = num[i-1][j] + num[i][j-1] + mp[i][j] -num[i-1][j-1];
    	}
    }

    cin>>m;
    for (int i = 0; i < m; ++i)
    {
    	cin>>a1>>b1>>a2>>b2;
    	cout<<(num[a2][b2]-num[a1-1][b2]-num[a2][b1-1]+num[a1-1][b1-1])<<endl;
    }

    return 0;
}