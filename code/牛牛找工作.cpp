/**
 *为了找到自己满意的工作，牛牛收集了每种工作的难度和报酬。牛牛选工作的标准是在难度不超过自身能力值的情况下，牛牛选择报酬最高的工作。在牛牛选定了自己的工作后，牛牛的小伙伴们来找牛牛帮忙选工作，牛牛依然使用自己的标准来帮助小伙伴们。牛牛的小伙伴太多了，于是他只好把这个任务交给了你。 
输入描述:
每个输入包含一个测试用例。
每个测试用例的第一行包含两个正整数，分别表示工作的数量N(N<=100000)和小伙伴的数量M(M<=100000)。
接下来的N行每行包含两个正整数，分别表示该项工作的难度Di(Di<=1000000000)和报酬Pi(Pi<=1000000000)。
接下来的一行包含M个正整数，分别表示M个小伙伴的能力值Ai(Ai<=1000000000)。
保证不存在两项工作的报酬相同。


输出描述:
对于每个小伙伴，在单独的一行输出一个正整数表示他能得到的最高报酬。一个工作可以被多个人选择。

输入例子1:
3 3 
1 100 
10 1000 
1000000000 1001 
9 10 1000000000

输出例子1:
100 
1000 
1001

实际上对于每个难度的工作，只有报酬最高的那一种是可能成为答案的，剩下的都可以无视。
由于只有N项工作和M个小伙伴，最多只会出现N+M种难度(能力值)，所以可以把难度和能力值映射到不超过N+M个数上(std通过排序+map来完成)。
对这些难度(能力值)分别求出最高的报酬，再按i从小到大的顺序维护难度(能力值)不超过i的最大报酬。最后输出每个小伙伴对应的能力值以下的最高报酬即可。

时间复杂度

O((N+M)*log(N+M))
 *
 *
 * 
 */

作者：NotDeep
链接：https://www.nowcoder.com/discuss/70736
来源：牛客网

#include <bits/stdc++.h>
using namespace std;
 
map<int,int> mp;
int cnt = 0;
int ans[200005];
int d[100005], p[100005];	
int val[200005];			
int a[100005];				//答案这里是全局变量，所以自动初始化为0。

int main() {
    int n, m;
    scanf("%d%d", &n, &m);

    for(int i = 1; i <= n; i++) {
        scanf("%d%d", &d[i], &p[i]);
        val[i] = d[i];		//难度值和能力值的总和，这里是难度值
    }
    for(int i = 1; i <= m; i++) {
        scanf("%d", &a[i]);
        val[i + n] = a[i];	//难度值和能力值的总和，这里是能力值
    }

    sort(val + 1, val + 1 + n + m);		//将难度值和能力值排序

	//建立好一个二叉树，按照难度值和能力值从大到小的排列，这里可能有重复的
    for(int i = 1; i <= n + m; i++) {
        if(val[i] != val[i - 1]) {
            cnt++;
            mp[val[i]] = cnt;
        }
    }

	//将每一项难度相等的工作的最大报酬提取出来
    for(int i = 1; i <= n; i++) 
		ans[mp[d[i]]] = max(ans[mp[d[i]]], p[i]);
	//然后再按i从小到大的顺序维护难度(能力值)不超过i的最大报酬
    for(int i = 2; i <= n + m; i++) 
		ans[i] = max(ans[i], ans[i - 1]);
	//输出结果
    for(int i = 1; i <= m; i++)
        printf("%d\n", ans[mp[a[i]]]);
    return 0;
}